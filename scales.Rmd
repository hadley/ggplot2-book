```{r scales-chap, include = FALSE}
source("common.R")
columns(1, 2 / 3)
```

# Scales {#scales}

Scales in ggplot2 control the mapping from data to aesthetics. They take your data and turn it into something that you can see, like size, colour, position or shape. They also provide the tools that let you interpret the plot: the axes and legends. You can generate many plots without knowing how scales work, but understanding scales and learning how to manipulate them will give you much more control.

\index{Scales}

Formally, each scale is a function from a region in data space (the domain of the scale) to a region in aesthetic space (the range of the scale). The axis or legend is the inverse function: it allows you to convert visual properties back to data. In ggplot2 these two roles are controlled by the same toolkit (the scale functions), but for expository reasons they are discussed separately in this book. In this chapter I will focus on the mapping from the data to the aesthetics, and in Chapter \@ref(guides) I will return to axes and legends. 


## Scale specification {#scale-usage}

An important property of ggplot2 is the principle that every aesthetic in your plot is associated with exactly one scale. For instance, when you write:

```{r default-scales, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class))
```

What actually happens is this:

```{r, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) +
  scale_x_continuous() + 
  scale_y_continuous() + 
  scale_colour_discrete()
```

The original code did not specify any scales, so ggplot2 adds a default scale for each of the aesthetics used in the plot. The choice of default scale depends on both the aesthetic and the variable type. In this example `hwy` is a continuous variable mapped to the y aesthetic so the default scale is `scale_y_continuous()`; similarly `class` is discrete so when mapped to the colour aesthetic the default scale becomes `scale_colour_discrete()`. It would be tedious to manually add a scale every time you used a new aesthetic, so ggplot2 does it for you. But if you want to override the defaults, you'll need to add the scale yourself, like this: \index{Scales!defaults}

```{r, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) + 
  scale_x_continuous("A really awesome x axis label") +
  scale_y_continuous("An amazingly great y axis label")
```

The use of `+` to "add" scales to a plot is a little misleading. Following the principle that every aesthetic has exactly one scale, when two scale specifications conflict the latter takes precedence. In other words, when you `+` a scale, you're not actually adding it to the plot, but overriding the existing scale. This means that the following two specifications are equivalent: \indexc{+} 

```{r multiple-scales, fig.show = "hide", message = TRUE}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  scale_x_continuous("Label 1") +
  scale_x_continuous("Label 2")

ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  scale_x_continuous("Label 2")
```

Note the message: if you see this in your own code, you need to reorganise your code specification to only add a single scale.

A second thing to note is that there are multiple ways to specify a valid scale for an aesthetic. In the examples above I have tweaked the options of the default scales, but you can also override them completely with new scales: 
```{r, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) +
  scale_x_sqrt() + 
  scale_colour_brewer()
```

In a specification such as this, `scale_x_sqrt()` changes the settings associated with the x axis scale, and `scale_colour_brewer()` does the same with the colour scale. I'll talk more about these later in the chapter.

The scale functions intended for users all follow a common naming scheme. You’ve probably already figured out the scheme, but to be concrete, it’s made up of three pieces separated by "_":

1. `scale`
1. The name of the aesthetic (e.g., `colour`, `shape` or `x`)
1. The name of the scale (e.g., `continuous`, `discrete`, `brewer`).

The naming structure is often helpful, but can sometimes be ambiguous. For example, it is immediately clear that `scale_x_*` functions apply to the x aesthetic, but it takes a little more thought to recognise that they also govern the behaviour of other aesthetics that describe a horizontal position (e.g., the xmin, xmax, and xend aesthetics). Similarly, while the name `scale_colour_continuous()` clearly refers to the colour scale associated with a continuous variables, it is less obvious that `scale_colour_distiller()` is simply a different method for creating colour scales for continuous variables. In this chapter I will try to clarify this structure as much as possible: more generally, the help documentation for each scale function may be helpful.

Before diving into the details of how scale functions work, it is useful to note that internally all scale functions in ggplot2 belong to one of three fundamental types; continuous scales, discrete scales, and binned scales. Each fundamental type is handled by one of three scale constructor functions---`continuous_scale()`, `discrete_scale()` and `binned_scale()`---and though as a user you should never need to call these functions yourself it is for this reason later sections in this chapter are sometimes subdivided into these three categories.



### Exercises

1.  What happens if you pair a discrete variable to a continuous scale?
    What happens if you pair a continuous variable to a discrete scale?

1.  Simplify the following plot specifications to make them easier to 
    understand.
    
    ```{r, eval = FALSE}
    ggplot(mpg, aes(displ)) + 
      scale_y_continuous("Highway mpg") + 
      scale_x_continuous() +
      geom_point(aes(y = hwy))

    ggplot(mpg, aes(y = displ, x = class)) + 
      scale_y_continuous("Displacement (l)") + 
      scale_x_discrete("Car type") +
      scale_x_discrete("Type of car") + 
      scale_colour_discrete() + 
      geom_point(aes(colour = drv)) + 
      scale_colour_discrete("Drive\ntrain")
    ```



## Scale limits {#limits}

Scales in ggplot2 are typically associated with limits that specify the domain over which the scale is defined and are usually derived from the range of the data. \index{Axis!limits} \index{Scales!limits} There are two reasons you might want to specify limits rather than relying on the data:

1. You want to shrink the limits to focus on an interesting area of the plot.
1. You want to expand the limits to make multiple plots match up.

It's most natural to think about the limits of position scales: they map directly to the ranges of the axes. But limits also apply to scales that have legends, like colour, size, and shape, and these limits are particularly important if you want colours to be consistent across multiple plots. To modify the limits of a scale, specify the `limits` parameter of the scale:

* For continuous scales, `limits` should be a numeric vector of length two. 
  If you only want to set the upper or lower limit, you can set the other value
  to `NA`.
* For discrete scales, `limits` is a character vector which enumerates all possible
  values.

A minimal example is shown below. In the left panel the limits of the x scale are set to the default values (the range of the data), the middle panel expands the limits, and the right panel shrinks them:

`r columns(3)`
```{r, messages = FALSE}
df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point() 

base
base + scale_x_continuous(limits = c(0, 4))
base + scale_x_continuous(limits = c(1.5, 2.5))
```

(The warning produced in the final example is discussed later in this section)

### Convenience functions

Because modifying scale limits is such a common task, ggplot2 provides some convenience functions to make this easier. For position scales the `xlim()` and `ylim()` helper functions inspect their input and then specify the appropriate scale for the x and y axes respectively. More generally, the `lims()` function takes name-value pairs as input, where the name specifies the aesthetic and the value specifies the limits. The results depend on the type of scale: \indexf{xlim}  \indexf{ylim}

* `xlim(10, 20)`: a continuous scale from 10 to 20
* `ylim(20, 10)`: a reversed continuous scale from 20 to 10
* `xlim("a", "b", "c")`: a discrete scale
* `xlim(as.Date(c("2008-05-01", "2008-08-01")))`: a date scale from May 1 to August 1 2008 (date scales are discussed in Section \@ref(date-scales))

Three examples using the `base` plot are shown below:

```{r, messages = FALSE}
base + xlim(0, 4)
base + xlim(4, 0)
base + lims(x = c(0, 4))
```

### Visual range expansion

If you have eagle eyes, you'll have noticed that the visual range of the axes actually extends a little bit past the numerical limits that I have specified in the various examples. This ensures that the data does not overlap the axes, which is usually (but not always) desirable. To eliminate this space, set `expand = c(0, 0)`. One scenario where it is usually preferable to remove this space is when using `geom_raster()`: \index{Axis!expansion}

`r columns(2, 1, 1)`
```{r}
ggplot(faithfuld, aes(waiting, eruptions)) + 
  geom_raster(aes(fill = density)) + 
  theme(legend.position = "none")

ggplot(faithfuld, aes(waiting, eruptions)) + 
  geom_raster(aes(fill = density)) + 
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  theme(legend.position = "none")
```

In the plot on the left the extra space is distracting, so the plot on the right would usually be preferable.

### Out of bounds values

Recall that an earlier plot in this section produced a warning about missing values when the scale limits were reduced. By default, ggplot2 converts data outside the limits to `NA`. This means that changing the limits of a scale is not precisely the same as visually zooming in to a region of the plot. If you want to do the latter, you should use the `xlim` and `ylim` arguments to `coord_cartesian()`, described in Section \@ref(cartesian), which performs purely visual zooming and does not affect the underlying data. \index{Zooming} To override the default behaviour you can set the `oob` (out of bounds) argument to the scale, a function that is applied to all observations outside the scale limits. The default `scales::censor()` which replaces any value outside the limits with `NA`. Another option is `scales::squish()` which squishes all values into the range. An example using a fill scale is shown below:

`r columns(3,1)`
```{r}
df <- data.frame(x = 1:6, y = 8:13)
base <- ggplot(df, aes(x, y)) + 
  geom_col(aes(fill = x)) +                    # bar chart
  geom_vline(xintercept = 3.5, colour = "red") # for visual clarity only

base
base + scale_fill_gradient(limits = c(1, 3))
base + scale_fill_gradient(limits = c(1, 3), oob = scales::squish)
```

On the left the default fill colours are shown, ranging from dark blue to light blue. In the middle panel the scale limits for the fill aesthetic are reduced so that the values for the three rightmost bars are replace with `NA` and are mapped to a grey shade. In some cases this is desired behaviour but often it is not: the right panel addresses this by modifying the `oob` function appropriately.  

### Exercises

1.  The following code creates two plots of the mpg dataset. Modify the code
    so that the legend and axes match, without using facetting!
    
    `r columns(2, 2/3)`
    ```{r}
    fwd <- subset(mpg, drv == "f")
    rwd <- subset(mpg, drv == "r")
    
    ggplot(fwd, aes(displ, hwy, colour = class)) + geom_point()
    ggplot(rwd, aes(displ, hwy, colour = class)) + geom_point()
    ```

1.  What does `expand_limits()` do and how does it work?  Read the source code.

1.  What happens if you add two `xlim()` calls to the same plot? Why?

1.  What does `scale_x_continuous(limits = c(NA, NA))` do?




## Position scales {#scale-position}

Every plot has two position scales corresponding to the x and y aesthetics. Typically the user specifies the variables mapped to x and y explicitly, but sometimes an aesthetic is mapped to a computed variable, as happens with `geom_histogram()`, and does not need to be explicitly specified. For example, the following plot specifications are equivalent:

```{r, fig.show = "hide", message = FALSE}
ggplot(mpg, aes(x = displ)) + geom_histogram()
ggplot(mpg, aes(x = displ, y = after_stat(count))) + geom_histogram()
```

Although the first example does not state the y-aesthetic mapping explicitly, it still exists and is associated with (in this case) a continuous position scale.

\index{Scales!position} \index{Positioning!scales} 


### Continuous position scales 

The most common continuous position scales are the default `scale_x_continuous()` and `scale_y_continuous()` functions, discussed earlier. In the simplest case they map linearly from the data value to a location on the plot. There are several other position scales for continuous variables---`scale_x_log10()`, `scale_x_reverse()`, etc---most of which are convenience functions used to provide easy access to common transformations:

`r columns(3)`
```{r}
base <- ggplot(mpg, aes(displ, hwy)) + geom_point()

base
base + scale_x_reverse()
base + scale_y_reverse()
```

Scale transformations are discussed in Section \@ref(scale-transformation).
\indexf{scale\_x\_continuous} 

### Discrete position scales

It is also possible to map discrete variables to position scales, with the default scales being `scale_x_discrete()` and `scale_y_discrete()` in this case. For example, the following two plot specifications are equivalent

```{r default-scales-discrete, fig.show = "hide"}
ggplot(mpg, aes(x = hwy, y = class)) + 
  geom_point()

ggplot(mpg, aes(x = hwy, y = class)) + 
  geom_point() + 
  scale_x_continuous() +
  scale_y_discrete()
```

Internally, ggplot2 treats handles discrete scales by mapping each category to an integer value and then drawing the geom at the corresponding coordinate location. To illustrate this, we can add a custom annotation (see Section \@ref(custom-annotations)) to the plot:

`r columns(1)`
```{r}
ggplot(mpg, aes(x = hwy, y = class)) + 
  geom_point() +
  annotate("text", x = 5, y = 1:7, label = 1:7)
```

### Binned position scales {#binned-position}

A variation on discrete position scales are binned scales, in which a continuous variable is sliced into multiple bins and the discretised variable is plotted. For example, if we want to modify the plot above to show the number of observations at each location, we could use `geom_count()` instead of `geom_point()` so that the size of the dots scales with the number of observations. As the left plot below illustrates, this is an improvement but is still rather cluttered. To improve this, the plot on the right uses `scale_x_binned()` to cut the `hwy` values into 10 bins before passing them to the geom:

`r columns(2)`
```{r}
base <- ggplot(mpg, aes(hwy, class)) + geom_count()

base 
base + scale_x_binned(n.breaks = 10)
```



## Colour scales {#scale-colour}

After position, the most commonly used aesthetic is colour. There are quite a few different ways of mapping values to colours in ggplot2: four different gradient-based methods for continuous values, and two methods for mapping discrete values. 

### A little colour theory
<!-- ...as a treat -->

Before we look at the details of the different methods, it's useful to learn a little bit of colour theory. Colour theory is complex because the underlying biology of the eye and brain is complex, and this introduction will only touch on some of the more important issues. An excellent and more detailed exposition is available online at <http://tinyurl.com/clrdtls>. \index{Colour} \index{Scales!colour}

At the physical level, colour is produced by a mixture of wavelengths of light. To characterise a colour completely, we need to know the complete mixture of wavelengths. Fortunately for us the human eye only has three different colour receptors, and so we can summarise the perception of any colour with just three numbers. You may be familiar with the RGB encoding of colour space, which defines a colour by the intensities of red, green and blue light needed to produce it. One problem with this space is that it is not perceptually uniform: the two colours that are one unit apart may look similar or very different depending on where they are in the colour space. This makes it difficult to create a mapping from a continuous variable to a set of colours. There have been many attempts to come up with colours spaces that are more perceptually uniform.  We'll use a modern attempt called the HCL colour space, which has three components of **h**ue, **c**hroma and **l**uminance: \index{Colour!spaces}

* **Hue** ranges from 0 to 360 (an angle) and gives the "colour" of the colour (blue, red, orange, etc).
* **Chroma** is the "purity" of a colour, ranging from 0 (grey) to a maximum that varies with luminance.
* **Luminance** is the lightness of the colour, ranging from 0 (black) to 1 (white).

Hues are not perceived as being ordered: e.g. green does not seem "larger" than red. The perception of chroma and luminance are ordered.

The combination of these three components does not produce a simple geometric shape. Figure \@ref(fig:hcl) attempts to show the 3d shape of the space. Each slice is a constant luminance (brightness) with hue mapped to angle and chroma to radius.  You can see the centre of each slice is grey and the colours get more intense as they get closer to the edge.


```{r hcl, echo = FALSE, out.width = "100%", fig.cap="The shape of the HCL colour space.  Hue is mapped to angle, chroma to radius and each slice shows a different luminance.  The HCL space is a pretty odd shape, but you can see that colours near the centre of each slice are grey, and as you move towards the edges they become more intense.  Slices for luminance 0 and 100 are omitted because they would, respectively, be a single black point and a single white point."}
knitr::include_graphics("diagrams/hcl-space.png", dpi = 300)
```

An additional complication is that many people (~10% of men) do not possess the normal complement of colour receptors and so can distinguish fewer colours than usual. \index{Colour!blindness} In brief, it's best to avoid red-green contrasts, and to check your plots with systems that simulate colour blindness. Visicheck is one online solution. Another alternative is the **dichromat** package [@dichromat] which provides tools for simulating colour blindness, and a set of colour schemes known to work well for colour-blind people. You can also help people with colour blindness in the same way that you can help people with black-and-white printers: by providing redundant mappings to other aesthetics like size, line type or shape.

### Continuous colour scales {#colour-continuous}

Colour gradients are often used to show the height of a 2d surface. The plots in this section use the surface of a 2d density estimate of the `faithful` dataset [@azzalini:1990], which records the waiting time between eruptions and during each eruption for the Old Faithful geyser in Yellowstone Park. I hide the legends and set `expand` to 0, to focus on the appearance of the data. Remember: although I use the `erupt` plot to illustrate concepts using with a fill aesthetic, the same ideas apply to colour scales. Any time I refer to `scale_fill_*()` in this section there is a corresponding `scale_colour_*()` for the colour aesthetic (or `scale_color_*()` if you prefer US spelling).
\index{Colour!gradients} \index{Scales!colour}

`r columns(3, 1)`
```{r}
erupt <- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) +
  geom_raster() +
  scale_x_continuous(NULL, expand = c(0, 0)) + 
  scale_y_continuous(NULL, expand = c(0, 0)) + 
  theme(legend.position = "none")
```

There are multiple ways to specify continuous colour scales, and consequently there are many different scale functions. To provide some structure, I'll begin this section with a discussion of general purpose gradient scale functions that you can use to construct any scale you like, then proceed to talk about scales that provide hand-picked colour palettes you can use. 

#### Robust recipes

The default scale function is `scale_fill_continuous()` which in turn defaults to `scale_fill_gradient()`. As a consequence, these three commands produce the same plot using a gradient scale:

```{r}
erupt
erupt + scale_fill_continuous()
erupt + scale_fill_gradient()
```

Gradient scales provide a robust method for creating any colour scheme you like. All you need to do is specify two or more reference colours, and ggplot2 will interpolate linearly between them. There are three functions that you can use for this purpose:
\indexf{scale\_colour\_gradient} \indexf{scale\_fill\_gradient} \indexf{scale\_colour\_gradient2} \indexf{scale\_fill\_gradient2}

- `scale_fill_gradient()` produces a two-colour gradient
- `scale_fill_gradient2()` produces a three-colour gradient with specified midpoint
- `scale_fill_gradientn()` produces an n-colour gradient

The use of gradient scales is illustrated below. The first plot uses a scale that linearly interpolates from grey (hex code: `"#bebebe"`) at the `low` end of the scale limits to brown (`"#a52a2a"`) at the `high` end. The second plot has the same endpoints but uses `scale_fill_gradient2()` to interpolate first from grey to white (`#ffffff`) and then from white to brown. Note that the `mid` argument specifies the colour to be shown at the intermediate point, and `midpoint` is the value in the data at which this colour is used (the default is `midpoint = 0`). The third method is to use `scale_fill_gradientn()` which takes a vector of reference `colours` as its argument, and constructs a scale that linearly interpolates between the specified values. By default, the `colours` are presumed to be equally spaced along the scale, but if you prefer you can specify a vector of `values` that correspond to each of the reference colours. 

```{r}
erupt + scale_fill_gradient(low = "grey", high = "brown")
erupt + scale_fill_gradient2(low = "grey", mid = "white", high = "brown", midpoint = .02)
erupt + scale_fill_gradientn(colours = terrain.colors(7))
```

Creating good colour palettes requires some care. Generally, for a two-point gradient scale you want to convey the perceptual impression that the values are sequentially ordered, so you want to keep hue constant, and vary chroma and luminance. The Munsell colour system is useful for this as it provides an easy way of specifying colours based on their hue, chroma and luminance. The munsell package [@munsell] provides easy access to the Munsell colours, which can then be used to specify a gradient scale: 

`r columns(2, 1)`
```{r}
munsell::hue_slice("5P") +  # generate a ggplot with hue_slice()
  annotate(                 # add arrows for annotation 
    geom = "segment", 
    x = c(7, 7), 
    y = c(1, 10), 
    xend = c(7, 7), 
    yend = c(2, 9), 
    arrow = arrow(length = unit(2, "mm"))
  ) 

# construct scale
erupt + scale_fill_gradient(
  low = munsell::mnsl("5P 2/12"), 
  high = munsell::mnsl("5P 7/12")
)
```

The labels on the left plot are a little difficult to read at this scale, so I have used `annotate()` to add arrows highlighting the column used to construct the scale on the right. For more information on the munsell package  see <https://github.com/cwickham/munsell/>.

Three-point gradient scales have slightly different design criteria. Typically the goal in such a scale is to convey the perceptual impression that there is a natural midpoint (often a zero value) from which the other values diverge. The left plot below shows how to create a divergent "yellow/blue" scale, though it is a little artificial in this example. 

Finally, if you have colours that are meaningful for your data (e.g., black body colours or standard terrain colours), or you'd like to use a palette produced by another package, you may wish to use an n-point gradient. As an illustration, the middle and right plots below use the **colorspace** package [@zeileis:2008]. <https://colorspace.r-forge.r-project.org/>
\index{Colour!palettes} \indexf{scale\_colour\_gradientn} \indexf{scale\_fill\_gradientn}


`r columns(3, 1)`
```{r}
# munsell example
erupt + scale_fill_gradient2(
  low = munsell::mnsl("5B 7/8"),
  high = munsell::mnsl("5Y 7/8"),
  mid = munsell::mnsl("N 7/0"),
  midpoint = .02
) 

# colorspace examples
erupt + scale_fill_gradientn(colours = colorspace::heat_hcl(7))
erupt + scale_fill_gradientn(colours = colorspace::diverge_hcl(7))
```
    

#### Particular palettes
    
In addition to the general purpose tools that the gradient scales provide, ggplot2 supplies two scale functions that bundle pre-specified palettes, `scale_fill_viridis_c()` and `scale_fill_distiller()`. The viridis scales [@viridis] are designed to be perceptually uniform in both colour and when reduced to black and white, and to be perceptible to people with various forms of colour blindness. Three examples are shown below:

```{r}
erupt + scale_fill_viridis_c(option = "viridis") # the default
erupt + scale_fill_viridis_c(option = "magma")
erupt + scale_fill_viridis_c(option = "plasma")
```

The second group of continuous colour scales built in to ggplot2 are derived from the ColorBrewer scales: `scale_fill_brewer()` provides these colours as discrete palettes, while `scale_fill_distiller()` and `scale_fill_fermenter()` are the continuous and binned analogs. I discuss these scales in Section \@ref(colour-discrete)), but for illustrative purposes include some examples here:

```{r}
erupt + scale_fill_distiller()
erupt + scale_fill_distiller(palette = "RdPu")
erupt + scale_fill_distiller(palette = "YlOrBr")
```

There are many other packages that provide useful colour palettes. For example,  scico [@scico] provides more palettes that are perceptually uniform and suitable for scientific visualisation:

```{r}
erupt + scico::scale_fill_scico(palette = "bilbao") # the default
erupt + scico::scale_fill_scico(palette = "vik")
erupt + scico::scale_fill_scico(palette = "lajolla")
```

However, as there are a great many palette packages in R, a particularly useful package is paletteer [@paletteer], which aims to provide a common interface:

```{r}
erupt + paletteer::scale_fill_paletteer_c("viridis::plasma")
erupt + paletteer::scale_fill_paletteer_c("scico::tokyo")
erupt + paletteer::scale_fill_paletteer_c("gameofthrones::targaryen")
```


#### Missing values

All continuous colour scales have an `na.value` parameter that controls what colour is used for missing values (including values outside the range of the scale limits). By default it is set to grey, which will stand out when you use a colourful scale. If you use a black and white scale, you might want to set it to something else to make it more obvious. You can set `na.value = NA` to make missing values invisible, or choose a specific colour if you prefer: \indexc{na.value} \index{Missing values!changing colour}

```{r}
df <- data.frame(x = 1, y = 1:5, z = c(1, 3, 2, NA, 5))
base <- ggplot(df, aes(x, y)) + geom_tile(aes(fill = z), size = 5)

base
base + scale_fill_gradient(na.value = NA)
base + scale_fill_gradient(low = "black", high = "white", na.value = "red")
```



### Discrete colour scales {#colour-discrete}

Discrete colour and fill scales occur in many situations. A typical example is a barchart that encodes both position and fill to the same variable. Many concepts from Section \@ref(colour-continuous) apply to discrete scales, which I will illustrate using this barchart as the running example: \index{Colour!discrete scales}

`r columns(3, 1)`
```{r}
df <- data.frame(x = c("a", "b", "c", "d"), y = c(3, 4, 1, 2))
bars <- ggplot(df, aes(x, y, fill = x)) + 
  geom_bar(stat = "identity") + 
  labs(x = NULL, y = NULL) +
  theme(legend.position = "none")
```

#### Hue, grey and manual scales

The default scale for discrete colours is `scale_fill_discrete()` which in turn defaults to `scale_fill_hue()` so these are identical plots:

```{r}
bars
bars + scale_fill_discrete()
bars + scale_fill_hue()
```

The default colour scheme picks evenly spaced hues around the HCL colour wheel. This works well for up to about eight colours, but after that it becomes hard to tell the different colours apart. You can control the default chroma and luminance, and the range of hues, with the `h`, `c` and `l` arguments:
\indexf{scale\_colour\_hue}
    
```{r}
bars
bars + scale_fill_hue(c = 40)
bars + scale_fill_hue(h = c(180, 300))
```
    
One disadvantage of the default colour scheme is that because the colours all have the same luminance and chroma, when you print them in black and white, they all appear as an identical shade of grey. Noting this, if you are intending a discrete colour scale to be printed in black and white, it is better to use `scale_fill_grey()` which maps discrete data to grays, from light to dark:
\indexf{scale\_colour\_grey} \index{Colour!greys}

```{r}
bars + scale_fill_grey()
bars + scale_fill_grey(start = 0.5, end = 1)
bars + scale_fill_grey(start = 0, end = 0.5)
```

Alternatively, if you have your own preferred colours, you can use `scale_fill_manual()` to set the colours by hand. This can be useful if you wish to choose colours that highlight a secondary grouping structure or draw attention to different comparisons:
\indexf{scale\_colour\_manual} 

```{r}
bars + scale_fill_manual(values = c("sienna1", "sienna4", "hotpink1", "hotpink4"))
bars + scale_fill_manual(values = c("tomato1", "tomato2", "tomato3", "tomato4"))
bars + scale_fill_manual(values = c("grey", "black", "grey", "grey"))
```


#### Brewer scales
    
`scale_colour_brewer()` is a discrete colour scale that---along with the continuous analog `scale_colour_distiller()` and binned analog `scale_colour_fermenter()`---uses handpicked "ColorBrewer" colours taken from <http://colorbrewer2.org/>. These colours have been designed to work well in a wide variety of situations, although the focus is on maps and so the colours tend to work better when displayed in large areas. There are many different options:
`r columns(1, 2)`
```{r}
RColorBrewer::display.brewer.all()
```

The first group of palettes are sequential scales that are useful when your discrete scale is ordered (e.g., rank data), and are available for continuous data using `scale_colour_distiller()`. For  unordered categorical data, the palettes most of interest are those in the second group. 'Set1' and 'Dark2' are particularly good for points, and 'Set2', 'Pastel1', 'Pastel2' and 'Accent' work well for areas. 
\index{Colour!Brewer} \indexf{scale\_colour\_brewer}

`r columns(3, 1)`
```{r}
bars + scale_fill_brewer(palette = "Set1")
bars + scale_fill_brewer(palette = "Set2")
bars + scale_fill_brewer(palette = "Accent")
```
    
Note that no palette is uniformly good for all purposes. Scatter plots typically use small plot markers, and bright colours tend to work better than subtle ones:

`r columns(3, 1)`
```{r brewer-pal}
# scatter plot
df <- data.frame(x = 1:3 + runif(30), y = runif(30), z = c("a", "b", "c"))
point <- ggplot(df, aes(x, y)) +
  geom_point(aes(colour = z))  + 
  theme(legend.position = "none") +
  labs(x = NULL, y = NULL)

# three palettes
point + scale_colour_brewer(palette = "Set1")
point + scale_colour_brewer(palette = "Set2")  
point + scale_colour_brewer(palette = "Pastel1")
```

Bar plots usually contain large patches of colour, and bright colours can be overwhelming. Subtle colours tend to work better in this situation:

```{r}
# bar plot
df <- data.frame(x = 1:3, y = 3:1, z = c("a", "b", "c"))
area <- ggplot(df, aes(x, y)) + 
  geom_bar(aes(fill = z), stat = "identity") + 
  theme(legend.position = "none") +
  labs(x = NULL, y = NULL)

# three palettes
area + scale_fill_brewer(palette = "Set1")
area + scale_fill_brewer(palette = "Set2")
area + scale_fill_brewer(palette = "Pastel1")
```

### Binned colour scales

Colour scales also come in binned versions. The default scale is `scale_fill_binned()` which in turn defaults to `scale_fill_steps()`. As with the binned position scales discussed in Section \@ref(binned-position) these scales have an `n.breaks` argument that controls the number of discrete colour categories created by the scale. Counterintuitively---because the human visual system is very good at detecting edges---this can sometimes make a continuous colour gradient easier to perceive:

```{r}
erupt + scale_fill_binned()
erupt + scale_fill_steps()
erupt + scale_fill_steps(n.breaks = 8)
```

In other respects `scale_fill_steps()` is analogous to `scale_fill_gradient()`, and allows you to construct your own two-colour gradients. There is also a three-colour variant `scale_fill_steps2()` and n-colour scale variant `scale_fill_stepsn()` that behave similarly to their continuous counterparts:

```{r}
erupt + scale_fill_steps(low = "grey", high = "brown")
erupt + scale_fill_steps2(low = "grey", mid = "white", high = "brown", midpoint = .02)
erupt + scale_fill_stepsn(n.breaks = 12, colours = terrain.colors(12))
```

A brewer analog for binned scales also exists, and is called `scale_fill_fermenter()`:

```{r}
erupt + scale_fill_fermenter(n.breaks = 9)
erupt + scale_fill_fermenter(n.breaks = 9, palette = "Oranges")
erupt + scale_fill_fermenter(n.breaks = 9, palette = "PuOr")
```

Note that like the discrete `scale_fill_brewer()`---and unlike the continuous `scale_fill_distiller()`---the binned function `scale_fill_fermenter()` does not interpolate between the brewer colours, and if you set `n.breaks` larger than the number of colours in the palette a warning message will appear and some colours will not be displayed.

## Size scales
\index{Size}

```{r, echo=FALSE}
planets <- data.frame(
  name = c("Mercury", "Venus", "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"),
  type = c(rep("Inner", 4), rep("Outer", 4)),
  position = 1:8,
  radius = c(2440, 6052, 6378, 3390, 71400, 60330, 25559, 24764),
  orbit = c(57900000, 108200000, 149600000, 227900000, 778300000, 1427000000, 2871000000, 4497100000)
#  mass = c(3.3022e+23, 4.8685e+24, 5.9736e+24, 6.4185e+23, 1.8986e+27, 5.6846e+26, 8.681e+25, 1.0243e+26)
)
planets$name <- with(planets, factor(name, name))
```

The size aesthetic is typically used to scale points and text. The default scale for size aesthetics is `scale_size()` in which a linear increase in the variable is mapped onto a linear increase in the area (not the radius) of the geom. Scaling as a function of area is a sensible default as human perception of size is more closely mimicked by area scaling than by radius scaling. By default the smallest value in the data (more precisely in the scale limits) is mapped to a size of 1 and the largest is mapped to a size of 6. The `range` argument allows you to scale the size of the geoms:
`r columns(2, 2/3)`
```{r}
base <- ggplot(mpg, aes(displ, hwy, size = cyl)) + 
  geom_point()

base
base + scale_size(range = c(1, 2))
```

There are situations where area scaling is undesirable, and for such situations the `scale_radius()` function is provided. To illustrate when `scale_radius()` is appropriate consider a data set containing astronomical data that includes the radius of different planets:
```{r} 
planets
```

In this instance a plot that uses the size aesthetic to represent the radius of the planets should use `scale_radius()` rather than the default `scale_size()`. It is also important in this case to set the scale limits so that a planet with radius 0 would be drawn with a disc with radius 0. 

`r columns(2, 1)`
```{r}
base <- ggplot(planets, aes(1, name, size = radius)) + 
  geom_point() + 
  scale_x_continuous(breaks = NULL) + 
  labs(x = NULL, y = NULL, size = NULL)
  
base + ggtitle("not to scale")
base + 
  scale_radius(limits = c(0, NA), range = c(0, 10)) + 
  ggtitle("to scale")
```

On the left it is difficult to distinguish Jupiter from Saturn, despite the fact that the difference between the two should be double the size of Earth; compare this to the plot on the right where the radius of Jupiter is visibly larger.

Other size scales exist and are worth noting briefly:

- `scale_size_binned()` is a size scale that behaves like `scale_size()` but maps continuous values onto discrete size categories (analogous to the binned position and colour scales discussed earlier)

- `scale_size_area()` and `scale_size_binned_area()` are versions of `scale_size()` and `scale_size_binned()` that ensure that a value of 0 maps to an area of 0. 

- `scale_size_date()` and `scale_size_datetime()` are designed to handle date data, analogous to the date scales discussed earlier.



## Other scales

Some other scale functions are worth discussing briefly:

*   Alpha scales map the transparency of a shade to a value in the data. They are not often useful, but can be a convenient way to visually down-weight less important observations. `scale_alpha()` is an alias for `scale_alpha_continuous()` since that is the most common use of alpha, and it saves a bit of typing.

*   Scales for discrete aesthetics --- for example `scale_linetype()`, `scale_shape()`, and `scale_colour_discrete()` --- basically have no options. These scales are just a list of valid values that are mapped to the unique discrete values. If you want to customise these scales, you need to create your own new scale with the "manual" version of each: `scale_linetype_manual()`, `scale_shape_manual()`, `scale_colour_manual()`, etc. The manual scale has one important argument, `values`, where you specify the values that the scale should produce: see Section \@ref(colour-discrete) for an example using manual colour scales. If this vector is named, it will match the values of the output to the values of the input; otherwise it will match in order of the levels of the discrete variable. You will need some knowledge of the valid aesthetic values, which are described in `vignette("ggplot2-specs")`. 
\index{Shape} \index{Line type}  \indexf{scale\_shape\_manual} \indexf{scale\_colour\_manual} \indexf{scale\_linetype\_manual}

*   Identity scales --- such as `scale_colour_identity()` and `scale_shape_identity()` --- are used when your data is already scaled such that the data and aesthetic spaces are the same. The code below shows an example where the identity scale is useful. `luv_colours` contains the locations of all R's built-in colours in the LUV colour space (the space that HCL is based on). A legend is unnecessary, because the point colour represents itself: the data and aesthetic spaces are the same. \index{Scales!identity} \indexf{scale\_identity}

    `r columns(1, 1, 0.75)`
    ```{r scale-identity}
    head(luv_colours)

    ggplot(luv_colours, aes(u, v)) + 
    geom_point(aes(colour = col), size = 3) + 
    scale_color_identity() + 
    coord_equal()
    ```



<!-- DN: Really not sure what to do with this example... -->

<!-- The following example shows a creative use of `scale_colour_manual()` to display multiple variables on the same plot and show a useful legend. In most other plotting systems, you'd colour the lines and then add a legend: \index{Data!longitudinal} -->

<!-- `r columns(1, 5/12, 0.8)` -->
<!-- ```{r huron} -->
<!-- huron <- data.frame(year = 1875:1972, level = as.numeric(LakeHuron)) -->
<!-- ggplot(huron, aes(year)) + -->
<!--   geom_line(aes(y = level + 5), colour = "red") + -->
<!--   geom_line(aes(y = level - 5), colour = "blue")  -->
<!-- ``` -->

<!-- That doesn't work in ggplot because there's no way to add a legend manually. Instead, give the lines informative labels: -->

<!-- ```{r huron2} -->
<!-- ggplot(huron, aes(year)) + -->
<!--   geom_line(aes(y = level + 5, colour = "above")) + -->
<!--   geom_line(aes(y = level - 5, colour = "below"))  -->
<!-- ``` -->

<!-- And then tell the scale how to map labels to colours: -->

<!-- ```{r huron3} -->
<!-- ggplot(huron, aes(year)) + -->
<!--   geom_line(aes(y = level + 5, colour = "above")) +  -->
<!--   geom_line(aes(y = level - 5, colour = "below")) +  -->
<!--   scale_colour_manual("Direction",  -->
<!--     values = c("above" = "red", "below" = "blue") -->
<!--   ) -->
<!-- ``` -->

<!-- ### Exercises -->

<!-- 1.  Compare and contrast the four continuous colour scales with the four discrete scales. -->

<!-- 1.  Explore the distribution of the built-in `colors()` using the `luv_colours` dataset. -->







## Scale transformation {#scale-transformation}

<!-- DN: This section is something of a promissory note. It ought to be possible to transform binned scales (e.g., reverse binned axis, construct bins on the reciprocal value etc, but I'm having problems getting this to work nicely). For now this is written as if only continuous transformations exist -->

When working with continuous data, the default is to map linearly from the data space onto the aesthetic space. It is possible to override this default using transformations. Every continuous scale takes a `trans` argument, allowing the use of a variety of transformations:
\index{Scales!position} \index{Transformation!scales} \index{Log!scale} \indexf{scale\_x\_log10}

`r columns(2, 1)`
```{r}
# convert from fuel economy to fuel consumption
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  scale_y_continuous(trans = "reciprocal")

# log transform x and y axes
ggplot(diamonds, aes(price, carat)) + 
  geom_bin2d() + 
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log10")
```

The transformation is carried out by a "transformer", which describes the transformation, its inverse, and how to draw the labels. You can construct your own transformer using `scales::trans_new()`, but --- as the plots above illustrate --- ggplot2 understands many common transformations supplied by the scales package. The following table lists the most common variants: 

| Name      | Function $f(x)$         | Inverse $f^{-1}(y)$
|-----------|-------------------------|------------------------
| asn       | $\tanh^{-1}(x)$         | $\tanh(y)$
| exp       | $e ^ x$                 | $\log(y)$
| identity  | $x$                     | $y$
| log       | $\log(x)$               | $e ^ y$
| log10     | $\log_{10}(x)$          | $10 ^ y$
| log2      | $\log_2(x)$             | $2 ^ y$
| logit     | $\log(\frac{x}{1 - x})$ | $\frac{1}{1 + e(y)}$
| pow10     | $10^x$                  | $\log_{10}(y)$
| probit    | $\Phi(x)$               | $\Phi^{-1}(y)$
| reciprocal| $x^{-1}$                | $y^{-1}$
| reverse   | $-x$                    | $-y$
| sqrt      | $x^{1/2}$               | $y ^ 2$

To simplify matters, ggplot2 provides convenience functions for the most common transformations: `scale_x_log10()`, `scale_x_sqrt()` and `scale_x_reverse()` provide the relevant transformation on the x axis, with similar functions provided for the y axis. Thus code below produces the same two plots shown in the previous example:

```{r, fig.show="hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() +
  scale_y_reverse()

ggplot(diamonds, aes(price, carat)) + 
  geom_bin2d() + 
  scale_x_log10() +
  scale_y_log10()
```

Note that there is nothing preventing you from performing these transformations manually. For example, instead of using `scale_x_log10()` to transform the scale, you could transform the data instead and plot `log10(x)`. The appearance of the geom will be the same, but the tick labels will be different. Specifically, if you use a transformed scale, the axes will be labelled in the original data space; if you transform the data, the axes will be labelled in the transformed space. Regardless of which method you use, the transformation occurs before any statistical summaries. To transform _after_ statistical computation use `coord_trans()`. See Section \@ref(cartesian) for more details.

Although the most common use for transformations is to adjust position scales, they can sometimes be helpful to when applied to other aesthetics. Often this is purely a matter of visual emphasis. An example of this for the Old Faithful density plot is shown below. The linearly mapped scale on the left makes it easy to see the peaks of the distribution, whereas the transformed representation on the right makes it easier to see the regions of non-negligible density around those peaks:

`r columns(2, 2/3)`
```{r}
base <- ggplot(faithfuld, aes(waiting, eruptions)) + 
  geom_raster(aes(fill = density)) + 
  scale_x_continuous(NULL, NULL, expand = c(0, 0)) +
  scale_y_continuous(NULL, NULL, expand = c(0, 0))
  
base
base + scale_fill_continuous(trans = "sqrt")
```

Transforming size aesthetics is also possible:

`r columns(2, 2/3)`
```{r}
df <- data.frame(x = runif(20), y = runif(20), z = sample(20))
base <- ggplot(df, aes(x, y, size = z)) + geom_point()

base 
base + scale_size(trans = "reverse")
```

In the plot on the left, the `z` value is naturally interpreted as a "weight": if each dot corresponds to a group, the `z` value might be the size of the group. In the plot on the right, the size scale is reversed, and `z` is more naturally interpreted as a "distance" measure: distant entities are scaled to appear smaller in the plot.






<!-- DN: This was the beginning of the binned transformation section:

### Binned scales

`r columns(2)`
```{r}
base <- ggplot(mpg, aes(hwy)) + geom_bar()

p1 <- base + scale_x_binned(breaks = seq(-50,50,10), limits = c(-50, 50))
p2 <- base + scale_x_binned(breaks = seq(-50,50,10), limits = c(-50, 50), trans = "reverse")
```





Binned scales can be transformed, much like continuous scales, but some care is required because the bins are constructed in the transformed space. In some cases this can produce undesirable outcomes. In the code below, I take a uniformly distributed variable and use `scale_x_binned()` and `geom_bar()` to construct a histogram of the logarithmically transformed data. 

`r columns(1, 1/2, 1)`
```{r}
df <- data.frame(val = runif(10000, 1, 20000))
ggplot(df, aes(log10(val))) + geom_bar() + scale_x_binned()
```

In this example the transformation takes place in the data: the x aesthetic is mapped to the value of `log10(val)`, and no scale transformation is applied. The bins are evenly spaced on this logarithmic scale. Alternatively, you can specify the transformation by setting `trans = "log10"` in the scale function:

`r columns(1, 1/2, 1)`
```{r}
ggplot(df, aes(val)) + geom_bar() + scale_x_binned(trans="log10") 
```

The unevenly spaced bins occur due to an interaction of two things: (1) binned scales use breaks to construct the bins, and (2) the default breaks for a transformed scale are specified by the transformation and are designed to look nice, but may not be good for binning data. The solution to this is to override the default breaks: 

`r columns(1, 1/2, 1)`
```{r}
ggplot(df, aes(val)) + geom_bar() + 
  scale_x_binned(trans="log10", breaks = 3^(0:9))  
```

-->

