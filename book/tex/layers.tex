\chapter{Build a plot layer by layer}\label{cha:layers}

\section{Introduction}

One of the key ideas behind ggplot2 is that it allows you to easily
iterate, building up a complex plot a layer at a time. Each layer can
come from a different dataset and have a different aesthetic mapping,
making it possible to create sophisticated plots that display data from
multiple sources.

You've already created layers with functions like \texttt{geom\_point()}
and \texttt{geom\_histogram()}. In this chapter, you'll dive into the
details of a layer, and how you can control all five components: data,
the aesthetic mappings, the geom, stat, and position adjustments. The
goal here is to give you the tools to build sophisticated plots tailored
to the problem at hand.

\section{Building a plot}

So far, whenever we've created a plot with \texttt{ggplot()}, we've
immediately added on a layer with a geom function. But it's important to
realise that there really are two distinct steps. First we create a plot
with default dataset and aesthetic mappings:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy))}
\NormalTok{p}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\linewidth]{_figures/layers/layer1-1}
\end{figure}

There's nothing to see yet, so we need to add a layer:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p +}\StringTok{ }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\linewidth]{_figures/layers/unnamed-chunk-1-1}
\end{figure}

\texttt{geom\_point()} is a shortcut. Behind the scenes it calls the
\texttt{layer()} function to create a new layer: \indexf{layer}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{p +}\StringTok{ }\KeywordTok{layer}\NormalTok{(}
  \DataTypeTok{mapping =} \OtherTok{NULL}\NormalTok{, }
  \DataTypeTok{data =} \OtherTok{NULL}\NormalTok{,}
  \DataTypeTok{geom =} \StringTok{"point"}\NormalTok{, }\DataTypeTok{geom_params =} \KeywordTok{list}\NormalTok{(),}
  \DataTypeTok{stat =} \StringTok{"identity"}\NormalTok{, }\DataTypeTok{stat_params =} \KeywordTok{list}\NormalTok{(),}
  \DataTypeTok{position =} \StringTok{"identity"}
\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This call fully specifies the five components to the layer:
\index{Layers!components}

\begin{itemize}
\item
  \textbf{mapping}: A set of aesthetic mappings, specified using the
  \texttt{aes()} function and combined with the plot defaults as
  described in \hyperref[sec:aes]{aesthetic mappings}. If \texttt{NULL},
  uses the default mapping set in \texttt{ggplot()}.
\item
  \textbf{data}: A dataset which overrides the default plot dataset. It
  is usually omitted (set to \texttt{NULL}), in which case the layer
  will use the default data specified in \texttt{ggplot()}. The
  requirements for data are explained in more detail in
  \hyperref[sec:data]{data}.
\item
  \textbf{geom}: The name of the geometric object to use to draw each
  observation. Geoms are discussed in more detail in
  \hyperref[sec:data]{geom}, and \hyperref[cha:toolbox]{the toolbox}
  explores their use in more depth.

  Geoms can have additional arguments. All geoms take aesthetics as
  parameters. If you supply an aesthetic (e.g.~colour) as a parameter,
  it will not be scaled, allowing you to control the appearance of the
  plot, as described in \hyperref[sub:setting-mapping]{setting
  vs.~mapping}. You can pass params in \texttt{...} (in which case stat
  and geom parameters are automatically teased apart), or in a list
  passed to \texttt{geom\_params}.
\item
  \textbf{stat}: The name of the statistical tranformation to use. A
  statistical transformation performs some useful statistical summary,
  and is key to histograms and smoothers. To keep the data as is, use
  the ``identity'' stat. Learn more in \hyperref[sec:stat]{statistical
  transformations}.

  You only need to set one of stat and geom: every geom has a default
  stat, and every stat a default geom.

  Most stats take additional parameters to specify the details of
  statistical transformation. You can supply params either in
  \texttt{...} (in which case stat and geom parameters are automatically
  teased apart), or in a list called \texttt{stat\_params}.
\item
  \textbf{position}: The method used to adjust overlapping objects, like
  jittering, stacking or dodging. More details in
  \hyperref[sec:position]{position}.
\end{itemize}

It's useful to understand the \texttt{layer()} function so you have a
better mental model of the layer object. But you'll rarely use the full
\texttt{layer()} call because it's so verbose. Instead, you'll use the
shortcut \texttt{geom\_} functions:
\texttt{geom\_point(mapping,\ data,\ ...)} is exactly equivalent to
\texttt{layer(mapping,\ data,\ geom\ =\ "point",\ ...)}.

\hyperdef{}{sec:data}{\section{Data}\label{sec:data}}

Every layer must have some data associated with it, and that data must
be in a tidy data frame. You'll learn about tidy data in
\hyperref[cha:data]{tidy data}, but for now, all you need to know is
that a tidy data frame has variables in the columns and observations in
the rows. This is a strong restriction, but there are good reasons for
it: \index{Data} \indexf{data.frame}

\begin{itemize}
\item
  Your data is very important, so it's best to be explicit about it.
\item
  A single data frame is also easier to save than a multitude of
  vectors, which means it's easier to reproduce your results or send
  your data to someone else.
\item
  It enforces a clean separation of concerns: ggplot2 turns data frames
  into visualisations. Other packages can make data frames in the right
  format (learn more about that in \hyperref[sub:modelvis]{model
  visualisation}).
\end{itemize}

The data on each layer doesn't need to be the same, and it's often
useful to combine multiple datasets in a single plot. To illustrate that
idea I'm going to generate two new datasets related to the mpg dataset.
First I'll fit a loess model and generate predictions from it. (This is
what \texttt{geom\_smooth()} does behind the scenes)

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{loess}\NormalTok{(hwy ~}\StringTok{ }\NormalTok{displ, }\DataTypeTok{data =} \NormalTok{mpg)}
\NormalTok{grid <-}\StringTok{ }\KeywordTok{data_frame}\NormalTok{(}\DataTypeTok{displ =} \KeywordTok{seq}\NormalTok{(}\KeywordTok{min}\NormalTok{(mpg$displ), }\KeywordTok{max}\NormalTok{(mpg$displ), }\DataTypeTok{length =} \DecValTok{50}\NormalTok{))}
\NormalTok{grid$hwy <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(mod, }\DataTypeTok{newdata =} \NormalTok{grid)}

\NormalTok{grid}
\CommentTok{#> Source: local data frame [50 x 2]}
\CommentTok{#> }
\CommentTok{#>    displ   hwy}
\CommentTok{#>    (dbl) (dbl)}
\CommentTok{#> 1   1.60  33.1}
\CommentTok{#> 2   1.71  32.2}
\CommentTok{#> 3   1.82  31.3}
\CommentTok{#> 4   1.93  30.4}
\CommentTok{#> 5   2.04  29.6}
\CommentTok{#> 6   2.15  28.8}
\CommentTok{#> ..   ...   ...}
\end{Highlighting}
\end{Shaded}

Next, I'll isolate observations that are particularly far away from
their predicted values:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{std_resid <-}\StringTok{ }\KeywordTok{resid}\NormalTok{(mod) /}\StringTok{ }\NormalTok{mod$s}
\NormalTok{outlier <-}\StringTok{ }\KeywordTok{filter}\NormalTok{(mpg, }\KeywordTok{abs}\NormalTok{(std_resid) >}\StringTok{ }\DecValTok{2}\NormalTok{)}
\NormalTok{outlier}
\CommentTok{#> Source: local data frame [6 x 11]}
\CommentTok{#> }
\CommentTok{#>   manufacturer      model displ  year   cyl      trans   drv   cty}
\CommentTok{#>          (chr)      (chr) (dbl) (int) (int)      (chr) (chr) (int)}
\CommentTok{#> 1    chevrolet   corvette   5.7  1999     8 manual(m6)     r    16}
\CommentTok{#> 2      pontiac grand prix   3.8  2008     6   auto(l4)     f    18}
\CommentTok{#> 3      pontiac grand prix   5.3  2008     8   auto(s4)     f    16}
\CommentTok{#> 4   volkswagen      jetta   1.9  1999     4 manual(m5)     f    33}
\CommentTok{#> 5   volkswagen new beetle   1.9  1999     4 manual(m5)     f    35}
\CommentTok{#> 6   volkswagen new beetle   1.9  1999     4   auto(l4)     f    29}
\CommentTok{#> Variables not shown: hwy (int), fl (chr), class (chr)}
\end{Highlighting}
\end{Shaded}

I've generated these datasets because it's common to enhance the display
of raw data with a statistical summary and some annotations. With these
new datasets, I can improve our initial scatterplot by overlaying a
smoothed line, and labelling the outlying points:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_line}\NormalTok{(}\DataTypeTok{data =} \NormalTok{grid, }\DataTypeTok{colour =} \StringTok{"blue"}\NormalTok{, }\DataTypeTok{size =} \FloatTok{1.5}\NormalTok{) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_text}\NormalTok{(}\DataTypeTok{data =} \NormalTok{outlier, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{label =} \NormalTok{model))}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\linewidth]{_figures/layers/unnamed-chunk-2-1}
\end{figure}

(The labels aren't particularly easy to read, but you can fix that with
some manual tweaking.)

Note that you need the explicit \texttt{data\ =} in the layers, but not
in the call to \texttt{ggplot()}. That's because the argument order is
different. This is a little inconsistent, but it reduces typing for the
common case where you specify the data once in \texttt{ggplot()} and
modify aesthetics in each layer.

In this example, every layer uses a different dataset. We could define
the same plot in another way, omitting the default dataset, and
specifying a dataset for each layer:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(displ, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{data =} \NormalTok{mpg) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_line}\NormalTok{(}\DataTypeTok{data =} \NormalTok{grid) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_text}\NormalTok{(}\DataTypeTok{data =} \NormalTok{outlier, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{label =} \NormalTok{model))}
\end{Highlighting}
\end{Shaded}

I don't particularly like this style in this example because it makes it
less clear what the primary dataset is (and because of the way that the
arguments to \texttt{ggplot()} are ordered, it actually requires more
keystrokes). However, you may prefer it in cases where there isn't a
clear primary dataset, or where the aesthetics also vary from layer to
layer.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The first two arguments to ggplot are \texttt{data} and
  \texttt{mapping}. The first two arguments to all layer functions are
  \texttt{mapping} and \texttt{data}. Why does the order of the
  arguments differ? (Hint: think about what you set most commonly.)
\item
  The following code uses dplyr to generate some summary statistics
  about each class of car (you'll learn how it works in
  \hyperref[cha:dplyr]{data transformation}).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(dplyr)}
\NormalTok{class <-}\StringTok{ }\NormalTok{mpg %>%}\StringTok{ }
\StringTok{  }\KeywordTok{group_by}\NormalTok{(class) %>%}\StringTok{ }
\StringTok{  }\KeywordTok{summarise}\NormalTok{(}\DataTypeTok{n =} \KeywordTok{n}\NormalTok{(), }\DataTypeTok{hwy =} \KeywordTok{mean}\NormalTok{(hwy))}
\end{Highlighting}
\end{Shaded}

  Use the data to recreate this plot:

  \begin{figure}[H]
    \centering
    \includegraphics[width=0.65\linewidth]{_figures/layers/unnamed-chunk-5-1}
  \end{figure}
\end{enumerate}

\hyperdef{}{sec:aes}{\section{Aesthetic mappings}\label{sec:aes}}

The aesthetic mappings, defined with \texttt{aes()}, describe how
variables are mapped to visual properties or \textbf{aesthetics}.
\texttt{aes()} takes a sequence of aesthetic-variable pairs like this:
\index{Aesthetics!mapping} \indexf{aes}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =} \NormalTok{displ, }\DataTypeTok{y =} \NormalTok{hwy, }\DataTypeTok{colour =} \NormalTok{class)}
\end{Highlighting}
\end{Shaded}

(If you're American, you can use \emph{color}, and behind the scenes
ggplot2 will correct your spelling ;)

Here we map x-position to \texttt{displ}, y-position to \texttt{hwy},
and colour to \texttt{class}. The names for the first two arguments can
be omitted, in which case they correspond to the x and y variables. That
makes this specification equivalent to the one above:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{aes}\NormalTok{(displ, hwy, }\DataTypeTok{colour =} \NormalTok{class)}
\end{Highlighting}
\end{Shaded}

While you can do data manipulation in \texttt{aes()}, e.g.
\texttt{aes(log(carat),\ log(price))}, it's best to only do simple
calculations. It's better to move complex transformations out of the
\texttt{aes()} call and into an explicit \texttt{dplyr::mutate()} call,
as you'll learn about in \hyperref[mutate]{mutate}. This makes it easier
to check your work and it's often faster because you need only do the
transformation once, not every time the plot is drawn.

Never refer to a variable with \texttt{\$} (e.g.,
\texttt{diamonds\$carat}) in \texttt{aes()}. This breaks containment, so
that the plot no longer contains everything it needs, and causes
problems if ggplot2 changes the order of the rows, as it does when
facetting. \indexc{\$}

\subsection{Specifying the aesthetics in the plot vs.~in the
layers}\label{sub:plots-and-layers}

Aesthetic mappings can be supplied in the initial \texttt{ggplot()}
call, in individual layers, or in some combination of both. All of these
calls create the same plot specification:
\index{Aesthetics!plot vs. layer}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy, }\DataTypeTok{colour =} \NormalTok{class)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{()}
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =} \NormalTok{class))}
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{hwy, }\DataTypeTok{colour =} \NormalTok{class))}
\KeywordTok{ggplot}\NormalTok{(mpg) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(displ, hwy, }\DataTypeTok{colour =} \NormalTok{class))}
\end{Highlighting}
\end{Shaded}

Within each layer, you can add, override, or remove mappings:

\begin{longtable}[c]{@{}lll@{}}
\toprule
Operation & Layer aesthetics & Result\tabularnewline
\midrule
\endhead
Add & \texttt{aes(colour\ =\ cyl)} &
\texttt{aes(mpg,\ wt,\ colour\ =\ cyl)}\tabularnewline
Override & \texttt{aes(y\ =\ disp)} &
\texttt{aes(mpg,\ disp)}\tabularnewline
Remove & \texttt{aes(y\ =\ NULL)} & \texttt{aes(mpg)}\tabularnewline
\bottomrule
\end{longtable}

If you only have one layer in the plot, the way you specify aesthetics
doesn't make any difference. However, the distinction is important when
you start adding additional layers. These two plots are both valid and
interesting, but focus on quite different aspects of the data:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy, }\DataTypeTok{colour =} \NormalTok{class)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_smooth}\NormalTok{(}\DataTypeTok{method =} \StringTok{"lm"}\NormalTok{, }\DataTypeTok{se =} \OtherTok{FALSE}\NormalTok{) +}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"none"}\NormalTok{)}

\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =} \NormalTok{class)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_smooth}\NormalTok{(}\DataTypeTok{method =} \StringTok{"lm"}\NormalTok{, }\DataTypeTok{se =} \OtherTok{FALSE}\NormalTok{) +}\StringTok{ }
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"none"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \includegraphics[width=0.5\linewidth]{_figures/layers/unnamed-chunk-7-1}%
  \includegraphics[width=0.5\linewidth]{_figures/layers/unnamed-chunk-7-2}
\end{figure}

Generally, you want to set up the mappings to illuminate the structure
underlying the graphic and minimise typing. It may take some time before
the best approach is immediately obvious, so if you've iterated your way
to a complex graphic, it may be worthwhile to rewrite it to make the
structure more clear.

\hyperdef{}{sub:setting-mapping}{\subsection{Setting
vs.~mapping}\label{sub:setting-mapping}}

Instead of mapping an aesthetic property to a variable, you can set it
to a \emph{single} value by specifying it in the layer parameters. We
\textbf{map} an aesthetic to a variable (e.g.,
\texttt{aes(colour\ =\ cut)}) or \textbf{set} it to a constant (e.g.,
\texttt{colour\ =\ "red"}). If you want appearance to be governed by a
variable, put the specification inside \texttt{aes()}; if you want
override the default size or colour, put the value outside of
\texttt{aes()}. \index{Aesthetics!setting}

The following plots are created with similar code, but have rather
different outputs. The second plot \textbf{maps} (not sets) the colour
to the value `darkblue'. This effectively creates a new variable
containing only the value `darkblue' and then scales it with a colour
scale. Because this value is discrete, the default colour scale uses
evenly spaced colours on the colour wheel, and since there is only one
value this colour is pinkish.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(cty, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"darkblue"}\NormalTok{) }

\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(cty, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"darkblue"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \includegraphics[width=0.5\linewidth]{_figures/layers/layer15-1}%
  \includegraphics[width=0.5\linewidth]{_figures/layers/layer15-2}
\end{figure}

A third approach is to map the value, but override the default scale:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(cty, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"darkblue"}\NormalTok{)) +}\StringTok{ }
\StringTok{  }\KeywordTok{scale_colour_identity}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\linewidth]{_figures/layers/unnamed-chunk-8-1}
\end{figure}

This is most useful if you always have a column that already contains
colours. You'll learn more about that in
\hyperref[sub:scale-identity]{the identity scale}.

It's sometimes useful to map aesthetics to constants. For example, if
you want to display multiple layers with varying parameters, you can
``name'' each layer:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() +}
\StringTok{  }\KeywordTok{geom_smooth}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"loess"}\NormalTok{), }\DataTypeTok{method =} \StringTok{"loess"}\NormalTok{, }\DataTypeTok{se =} \OtherTok{FALSE}\NormalTok{) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_smooth}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"lm"}\NormalTok{), }\DataTypeTok{method =} \StringTok{"lm"}\NormalTok{, }\DataTypeTok{se =} \OtherTok{FALSE}\NormalTok{) +}
\StringTok{  }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{colour =} \StringTok{"Method"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\linewidth]{_figures/layers/unnamed-chunk-9-1}
\end{figure}

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Simplify the following plot specifications:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(mpg$disp, mpg$hwy))}

\KeywordTok{ggplot}\NormalTok{() +}\StringTok{ }
\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{hwy, }\DataTypeTok{x =} \NormalTok{cty), }\DataTypeTok{data =} \NormalTok{mpg) +}
\StringTok{ }\KeywordTok{geom_smooth}\NormalTok{(}\DataTypeTok{data =} \NormalTok{mpg, }\DataTypeTok{mapping =} \KeywordTok{aes}\NormalTok{(cty, hwy))}

\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(carat, price)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\KeywordTok{log}\NormalTok{(brainwt), }\KeywordTok{log}\NormalTok{(bodywt)), }\DataTypeTok{data =} \NormalTok{msleep)}
\end{Highlighting}
\end{Shaded}
\item
  What does the following code do? Does it work? Does it make sense?
  Why/why not?

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg) +}
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\KeywordTok{aes}\NormalTok{(class, cty)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_boxplot}\NormalTok{(}\KeywordTok{aes}\NormalTok{(trans, hwy))}
\end{Highlighting}
\end{Shaded}
\item
  What happens if you try to use a continuous variable on the x axis in
  one layer, and a categorical variable in another layer? What happens
  if you do it in the opposite order?
\end{enumerate}

\section{Geoms}\label{sec:geom}

Geometric objects, or \textbf{geoms} for short, perform the actual
rendering of the layer, controlling the type of plot that you create.
For example, using a point geom will create a scatterplot, while using a
line geom will create a line plot.

\begin{itemize}
\tightlist
\item
  Graphical primitives:

  \begin{itemize}
  \tightlist
  \item
    \texttt{geom\_blank()}: display nothing. Most useful for adjusting
    axes limits using data.
  \item
    \texttt{geom\_point()}: points.
  \item
    \texttt{geom\_path()}: paths.
  \item
    \texttt{geom\_ribbon()}: ribbons, a path with vertical thickness.
  \item
    \texttt{geom\_segment()}: a line segment, specified by start and end
    position.
  \item
    \texttt{geom\_rect()}: rectangles.
  \item
    \texttt{geom\_polyon()}: filled polygons.
  \item
    \texttt{geom\_text()}: text.
  \end{itemize}
\item
  One variable:

  \begin{itemize}
  \tightlist
  \item
    Discrete:

    \begin{itemize}
    \tightlist
    \item
      \texttt{geom\_bar()}: display distribution of discrete variable.
    \end{itemize}
  \item
    Continuous

    \begin{itemize}
    \tightlist
    \item
      \texttt{geom\_histogram()}: bin and count continuous variable,
      display with bars.
    \item
      \texttt{geom\_density()}: smoothed density estimate.
    \item
      \texttt{geom\_dotplot()}: stack individual points into a dot plot.
    \item
      \texttt{geom\_freqpoly()}: bin and count continuous variable,
      display with lines.
    \end{itemize}
  \end{itemize}
\item
  Two variables:

  \begin{itemize}
  \tightlist
  \item
    Both continuous:

    \begin{itemize}
    \tightlist
    \item
      \texttt{geom\_point()}: scatterplot.
    \item
      \texttt{geom\_quantile()}: smoothed quantile regression.
    \item
      \texttt{geom\_rug()}: marginal rug plots.
    \item
      \texttt{geom\_smooth()}: smoothed line of best fit.
    \item
      \texttt{geom\_text()}: text labels.
    \end{itemize}
  \item
    Show distribution:

    \begin{itemize}
    \tightlist
    \item
      \texttt{geom\_bin2d()}: bin into rectangles and count.
    \item
      \texttt{geom\_density2d()}: smoothed 2d density estimate.
    \item
      \texttt{geom\_hex()}: bin into hexagons and count.
    \end{itemize}
  \item
    At least one discrete:

    \begin{itemize}
    \tightlist
    \item
      \texttt{geom\_count()}: count number of point at distinct
      locations
    \item
      \texttt{geom\_jitter()}: randomly jitter overlapping points.
    \end{itemize}
  \item
    One continuous, one discrete:

    \begin{itemize}
    \tightlist
    \item
      \texttt{geom\_bar(stat\ =\ "identity")}: a bar chart of
      precomputed summaries.
    \item
      \texttt{geom\_boxplot()}: boxplots.
    \item
      \texttt{geom\_violin()}: show density of values in each group.
    \end{itemize}
  \item
    One time, one continuous

    \begin{itemize}
    \tightlist
    \item
      \texttt{geom\_area()}: area plot.
    \item
      \texttt{geom\_line()}: line plot.
    \item
      \texttt{geom\_step()}: step plot.
    \end{itemize}
  \item
    Display uncertainty:

    \begin{itemize}
    \tightlist
    \item
      \texttt{geom\_crossbar()}: vertical bar with center.
    \item
      \texttt{geom\_errorbar()}: error bars.
    \item
      \texttt{geom\_linerange()}: vertical line.
    \item
      \texttt{geom\_pointrange()}: vertical line with center.
    \end{itemize}
  \item
    Spatial

    \begin{itemize}
    \tightlist
    \item
      \texttt{geom\_map()}: fast version of \texttt{geom\_polygon()} for
      map data.
    \end{itemize}
  \end{itemize}
\item
  Three variables:

  \begin{itemize}
  \tightlist
  \item
    \texttt{geom\_contour()}: contours.
  \item
    \texttt{geom\_tile()}: tile the plane with rectangles.
  \item
    \texttt{geom\_raster()}: fast version of \texttt{geom\_tile()} for
    equal sized tiles.
  \end{itemize}
\end{itemize}

Each geom has a set of aesthetics that it understands, some of which
\emph{must} be provided. For example, the point geoms requires x and y
position, and understands colour, size and shape aesthetics. A bar
requires height (\texttt{ymax}), and understands width, border colour
and fill colour. Each geom lists its aesthetics in the documentation.

Some geoms differ primarily in the way that they are parameterised. For
example, you can draw a square in three ways:
\index{Geoms!parameterisation}

\begin{itemize}
\item
  By giving \texttt{geom\_tile()} the location (\texttt{x} and
  \texttt{y}) and dimensions (\texttt{width} and \texttt{height}).
  \indexf{geom\_tile}
\item
  By giving \texttt{geom\_rect()} top (\texttt{ymax}), bottom
  (\texttt{ymin}), left (\texttt{xmin}) and right (\texttt{xmax})
  positions. \indexf{geom\_rect}
\item
  By giving \texttt{geom\_polygon()} a four row data frame with the
  \texttt{x} and \texttt{y} positions of each corner.
\end{itemize}

Other related geoms are:

\begin{itemize}
\tightlist
\item
  \texttt{geom\_segment()} and \texttt{geom\_line()}
\item
  \texttt{geom\_area()} and \texttt{geom\_ribbon()}.
\end{itemize}

If alternative parameterisations are available, picking the right one
for your data will usually make it much easier to draw the plot you
want.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  Download and print out the ggplot2 cheatsheet from
  \url{http://www.rstudio.com/resources/cheatsheets/} so you have a
  handy visual reference for all the geoms.
\item
  Look at the documentation for the graphical primitive geoms. Which
  aesthetics do they use? How can you summarise them in a compact form?
\item
  What's the best way to master an unfamiliar geom? List three resources
  to help you get started.
\item
  For each of the plots below, identify the geom used to draw it.

  \begin{figure}[H]
    \includegraphics[width=0.5\linewidth]{_figures/layers/unnamed-chunk-12-1}%
    \includegraphics[width=0.5\linewidth]{_figures/layers/unnamed-chunk-12-2}
  \end{figure}

  \begin{figure}[H]
    \includegraphics[width=0.5\linewidth]{_figures/layers/unnamed-chunk-13-1}%
    \includegraphics[width=0.5\linewidth]{_figures/layers/unnamed-chunk-13-2}
  \end{figure}

  \begin{figure}[H]
    \includegraphics[width=0.5\linewidth]{_figures/layers/unnamed-chunk-14-1}%
    \includegraphics[width=0.5\linewidth]{_figures/layers/unnamed-chunk-14-2}
  \end{figure}
\item
  For each of the following problems, suggest a useful geom:

  \begin{itemize}
  \tightlist
  \item
    Display how a variable has changed over time.
  \item
    Show the detailed distribution of a single variable.
  \item
    Focus attention on the overall trend in a large dataset.
  \item
    Draw a map.
  \item
    Label outlying points.
  \end{itemize}
\end{enumerate}

\hyperdef{}{sec:stat}{\section{Stats}\label{sec:stat}}

A statistical transformation, or \textbf{stat}, transforms the data,
typically by summarising it in some manner. For example, a useful stat
is the smoother, which calculates the smoothed mean of y, conditional on
x. You've already used many of ggplot2's stats because they're used
behind the scenes to generate many important geoms:

\begin{itemize}
\tightlist
\item
  \texttt{stat\_bin()}: \texttt{geom\_bar()}, \texttt{geom\_freqpoly()},
  \texttt{geom\_histogram()}
\item
  \texttt{stat\_bin2d()}: \texttt{geom\_bin2d()}
\item
  \texttt{stat\_bindot()}: \texttt{geom\_dotplot()}
\item
  \texttt{stat\_binhex()}: \texttt{geom\_hex()}
\item
  \texttt{stat\_boxplot()}: \texttt{geom\_boxplot()}
\item
  \texttt{stat\_contour()}: \texttt{geom\_contour()}
\item
  \texttt{stat\_quantile()}: \texttt{geom\_quantile()}
\item
  \texttt{stat\_smooth()}: \texttt{geom\_smooth()}
\item
  \texttt{stat\_sum()}: \texttt{geom\_count()}
\end{itemize}

You'll rarely call these functions directly, but they are useful to know
about because their documentation often provides more detail about the
corresponding statistical transformation.

Other stats can't be created with a \texttt{geom\_} function:

\begin{itemize}
\tightlist
\item
  \texttt{stat\_ecdf()}: compute a empirical cumulative distribution
  plot.
\item
  \texttt{stat\_function()}: compute y values from a function of x
  values.
\item
  \texttt{stat\_summary()}: summarise y values at distinct x values.
\item
  \texttt{stat\_summary2d()}, \texttt{stat\_summary\_hex()}: summarise
  binned values.
\item
  \texttt{stat\_qq()}: perform calculations for a quantile-quantile
  plot.
\item
  \texttt{stat\_spoke()}: convert angle and radius to position.
\item
  \texttt{stat\_unique()}: remove duplicated rows.
\end{itemize}

There are two ways to use these functions. You can either add a
\texttt{stat\_()} function and override the default geom, or add a
\texttt{geom\_()} function and override the default stat:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(trans, cty)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() +}\StringTok{ }
\StringTok{  }\KeywordTok{stat_summary}\NormalTok{(}\DataTypeTok{geom =} \StringTok{"point"}\NormalTok{, }\DataTypeTok{fun.y =} \StringTok{"mean"}\NormalTok{, }\DataTypeTok{colour =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{size =} \DecValTok{4}\NormalTok{)}

\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(trans, cty)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{() +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{stat =} \StringTok{"summary"}\NormalTok{, }\DataTypeTok{fun.y =} \StringTok{"mean"}\NormalTok{, }\DataTypeTok{colour =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{size =} \DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.75\linewidth]{_figures/layers/unnamed-chunk-15-1}
\end{figure}

I think it's best to use the second form because it makes it more clear
that you're displaying a summary, not the raw data.

\subsection{Generated variables}

Internally, a stat takes a data frame as input and returns a data frame
as output, and so a stat can add new variables to the original dataset.
It is possible to map aesthetics to these new variables. For example,
\texttt{stat\_bin}, the statistic used to make histograms, produces the
following variables: \index{Stats!creating new variables}
\indexf{stat\_bin}

\begin{itemize}
\tightlist
\item
  \texttt{count}, the number of observations in each bin
\item
  \texttt{density}, the density of observations in each bin (percentage
  of total / bar width)
\item
  \texttt{x}, the centre of the bin
\end{itemize}

These generated variables can be used instead of the variables present
in the original dataset. For example, the default histogram geom assigns
the height of the bars to the number of observations (\texttt{count}),
but if you'd prefer a more traditional histogram, you can use the
density (\texttt{density}). To refer to a generated variable like
density, ``\texttt{..}'' must surround the name. This prevents confusion
in case the original dataset includes a variable with the same name as a
generated variable, and it makes it clear to any later reader of the
code that this variable was generated by a stat. Each statistic lists
the variables that it creates in its documentation. \indexc{..} Compare
the y-axes on these two plots:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(price)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{binwidth =} \DecValTok{500}\NormalTok{)}
\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(price)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_histogram}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{..density..), }\DataTypeTok{binwidth =} \DecValTok{500}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \includegraphics[width=0.5\linewidth]{_figures/layers/hist-1}%
  \includegraphics[width=0.5\linewidth]{_figures/layers/hist-2}
\end{figure}

This technique is particularly useful when you want to compare the
distribution of multiple groups that have very different sizes. For
example, it's hard to compare the distribution of \texttt{price} within
\texttt{cut} because some groups are quite small. It's easier to compare
if we standardise each group to take up the same area:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(price, }\DataTypeTok{colour =} \NormalTok{cut)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_freqpoly}\NormalTok{(}\DataTypeTok{binwidth =} \DecValTok{500}\NormalTok{) +}
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"none"}\NormalTok{)}

\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(price, }\DataTypeTok{colour =} \NormalTok{cut)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_freqpoly}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{y =} \NormalTok{..density..), }\DataTypeTok{binwidth =} \DecValTok{500}\NormalTok{) +}\StringTok{ }
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"none"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \includegraphics[width=0.5\linewidth]{_figures/layers/freqpoly-1}%
  \includegraphics[width=0.5\linewidth]{_figures/layers/freqpoly-2}
\end{figure}

The result of this plot is rather surprising: low quality diamonds seem
to be more expensive on average. We'll come back to this result in
\hyperref[sub:trend]{removing trend}.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  The code below creates a similar dataset to \texttt{stat\_smooth()}.
  Use the appropriate geoms to mimic the default \texttt{geom\_smooth()}
  display.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mod <-}\StringTok{ }\KeywordTok{loess}\NormalTok{(hwy ~}\StringTok{ }\NormalTok{displ, }\DataTypeTok{data =} \NormalTok{mpg)}
\NormalTok{smoothed <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{displ =} \KeywordTok{seq}\NormalTok{(}\FloatTok{1.6}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DataTypeTok{length =} \DecValTok{50}\NormalTok{))}
\NormalTok{pred <-}\StringTok{ }\KeywordTok{predict}\NormalTok{(mod, }\DataTypeTok{newdata =} \NormalTok{smoothed, }\DataTypeTok{se =} \OtherTok{TRUE}\NormalTok{) }
\NormalTok{smoothed$hwy <-}\StringTok{ }\NormalTok{pred$fit}
\NormalTok{smoothed$hwy_lwr <-}\StringTok{ }\NormalTok{pred$fit -}\StringTok{ }\FloatTok{1.96} \NormalTok{*}\StringTok{ }\NormalTok{pred$se.fit}
\NormalTok{smoothed$hwy_upr <-}\StringTok{ }\NormalTok{pred$fit +}\StringTok{ }\FloatTok{1.96} \NormalTok{*}\StringTok{ }\NormalTok{pred$se.fit}
\end{Highlighting}
\end{Shaded}
\item
  What stats were used to create the following plots?

  \begin{figure}[H]
    \includegraphics[width=0.333\linewidth]{_figures/layers/unnamed-chunk-17-1}%
    \includegraphics[width=0.333\linewidth]{_figures/layers/unnamed-chunk-17-2}%
    \includegraphics[width=0.333\linewidth]{_figures/layers/unnamed-chunk-17-3}
  \end{figure}
\item
  Read the help for \texttt{stat\_sum()} then use \texttt{geom\_count()}
  to create a plot that shows the proportion of cars that have each
  combination of \texttt{drv} and \texttt{trans}.
\end{enumerate}

\hyperdef{}{sec:position}{\section{Position
adjustments}\label{sec:position}}

\index{Position adjustments}

Position adjustments apply minor tweaks to the position of elements
within a layer. Three adjustments apply primarily to bars:

\index{Dodging} \index{Side-by-side|see{Dodging}}
\indexf{position\_dodge} \index{Stacking} \indexf{position\_stack}
\indexf{position\_fill}

\begin{itemize}
\tightlist
\item
  \texttt{position\_stack()}: stack overlapping bars (or areas) on top
  of each other.
\item
  \texttt{position\_fill()}: stack overlapping bars, scaling so the top
  is always at 1.
\item
  \texttt{position\_dodge()}: place overlapping bars (or boxplots)
  side-by-side.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplot <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(color, }\DataTypeTok{fill =} \NormalTok{cut)) +}\StringTok{ }
\StringTok{  }\KeywordTok{xlab}\NormalTok{(}\OtherTok{NULL}\NormalTok{) +}\StringTok{ }\KeywordTok{ylab}\NormalTok{(}\OtherTok{NULL}\NormalTok{) +}\StringTok{ }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"none"}\NormalTok{)}
\CommentTok{# position stack is the default for bars, so `geom_bar()` }
\CommentTok{# is equivalent to `geom_bar(position = "stack")`.}
\NormalTok{dplot +}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{()}
\NormalTok{dplot +}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"fill"}\NormalTok{)}
\NormalTok{dplot +}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"dodge"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \includegraphics[width=0.333\linewidth]{_figures/layers/position-bar-1}%
  \includegraphics[width=0.333\linewidth]{_figures/layers/position-bar-2}%
  \includegraphics[width=0.333\linewidth]{_figures/layers/position-bar-3}
\end{figure}

There's also a position adjustment that does nothing:
\texttt{position\_identity()}. The identity position adjustment is not
useful for bars, because each bar obscures the bars behind, but there
are many geoms that don't need adjusting, like the frequency polygon:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dplot +}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"identity"}\NormalTok{, }\DataTypeTok{alpha =} \DecValTok{1} \NormalTok{/}\StringTok{ }\DecValTok{2}\NormalTok{, }\DataTypeTok{colour =} \StringTok{"grey50"}\NormalTok{)}

\KeywordTok{ggplot}\NormalTok{(diamonds, }\KeywordTok{aes}\NormalTok{(color, }\DataTypeTok{colour =} \NormalTok{cut)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_freqpoly}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{group =} \NormalTok{cut), }\DataTypeTok{stat =} \StringTok{"count"}\NormalTok{) +}\StringTok{ }
\StringTok{  }\KeywordTok{xlab}\NormalTok{(}\OtherTok{NULL}\NormalTok{) +}\StringTok{ }\KeywordTok{ylab}\NormalTok{(}\OtherTok{NULL}\NormalTok{) +}\StringTok{ }
\StringTok{  }\KeywordTok{theme}\NormalTok{(}\DataTypeTok{legend.position =} \StringTok{"none"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \includegraphics[width=0.5\linewidth]{_figures/layers/position-identity-1}%
  \includegraphics[width=0.5\linewidth]{_figures/layers/position-identity-2}
\end{figure}

There are three position adjustments that are primarily useful for
points:

\begin{itemize}
\tightlist
\item
  \texttt{position\_nudge()}: move points by a fixed offset.
\item
  \texttt{position\_jitter()}: add a little random noise to every
  position.
\item
  \texttt{position\_jitterdodge()}: dodge points within groups, then add
  a little random noise.
\end{itemize}

\indexf{position\_nudge} \indexf{position\_jitter}
\indexf{position\_jitterdodge}

Note that the way you pass parameters to position adjustments differs to
stats and geoms. Instead of including additional arguments in
\texttt{...}, you construct a position adjustment object, supplying
additional arguments in the call:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{position =} \StringTok{"jitter"}\NormalTok{)}
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{position =} \KeywordTok{position_jitter}\NormalTok{(}\DataTypeTok{width =} \FloatTok{0.05}\NormalTok{, }\DataTypeTok{height =} \FloatTok{0.5}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{figure}[H]
  \includegraphics[width=0.5\linewidth]{_figures/layers/position-point-1}%
  \includegraphics[width=0.5\linewidth]{_figures/layers/position-point-2}
\end{figure}

This is rather verbose, so \texttt{geom\_jitter()} provides a convenient
shortcut:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(mpg, }\KeywordTok{aes}\NormalTok{(displ, hwy)) +}\StringTok{ }
\StringTok{  }\KeywordTok{geom_jitter}\NormalTok{(}\DataTypeTok{width =} \FloatTok{0.05}\NormalTok{, }\DataTypeTok{height =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Continuous data typically doesn't overlap exactly, and when it does
(because of high data density) minor adjustments, like jittering, are
often insufficient to fix the problem. For this reason, position
adjustments are generally most useful for discrete data.

\subsection{Exercises}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  When might you use \texttt{position\_nudge()}? Read the documentation.
\item
  Many position adjustments can only be used with a few geoms. For
  example, you can't stack boxplots or errors bars. Why not? What
  properties must a geom possess in order to be stackable? What
  properties must it possess to be dodgeable?
\item
  Why might you use \texttt{geom\_jitter()} instead of
  \texttt{geom\_count()}? What are the advantages and disadvantages of
  each technique?
\item
  When might you use a stacked area plot? What are the advantages and
  disadvantages compared to a line plot?
\end{enumerate}
